// test.compute

#pragma kernel main
#include "optional.comp"
#include "shapes.comp"
#include "common.comp"

[[vk::binding(0, 0)]] RWTexture2D<float4> res;
[[vk::binding(1, 0)]] RWTexture2D<float4> transaction;
[[vk::push_constant]] struct Constants {
    uint rngSeed;
    uint sampleIndex;
    uint samplesPerPixel;
} push;

struct Camera 
{
    float3 position;
    float3 lookat;
};

#define SPHERES_COUNT 9
#define LIGHTS_COUNT 1

static Sphere spheres[SPHERES_COUNT] = {
    {1e5, float3( 1e5 + 1, 0, 0), float3(0, 0, 0),  float3(0.63, 0.065, 0.05), DIFF}, // Left Wall (Red)
    {1e5, float3(-1e5 - 1, 0, 0), float3(0, 0, 0), float3(.25, .25, .75), DIFF}, // Right Wall (Blue)
    {1e5, float3(0, 0, -1e5 - 1), float3(0, 0, 0), float3(.75, .75, .75), DIFF}, // Back Wall (White)
    {1e5, float3(0, 0, 1e5 + 2.15), float3(0, 0, 0), float3(.75, .75, .75), DIFF}, // Front Wall (White)
    {1e5, float3(0, -1e5 - 1, 0), float3(0, 0, 0), float3(.75, .75, .75), DIFF}, // Bottom Wall (White)
    {1e5, float3(0, 1e5 + 1, 0), float3(0, 0, 0), float3(.75, .75, .75), DIFF}, // Top Wall (White)
    {0.33, float3(-0.5,1-0.33,1.2), float3(0, 0, 0), float3(0.4, 0.2, 0.2), DIFF}, // Mirror Sphere (Specular reflection)
    {0.45, float3(0.35,1-0.45,1.5), float3(0, 0, 0), float3(0.14, 0.45, 0.091), DIFF}, // Glossy Sphere (Refractive material)
    {1,    float3(0,-1.9,1.5), 10*float3(0.8, 0.8, 0.8), float3(0,0,0), DIFF} // Light Sphere (Light-emitting sphere)
}; 

static Sphere lights[LIGHTS_COUNT] = {
    {1, float3(0,-1.9,1.5), 10*float3(0.8, 0.8, 0.8), float3(0, 0, 0), DIFF} // Light Sphere (Light-emitting sphere)
};

struct Intersection {
    float3 p;
    float t;
    uint i;
};

Optional<Intersection> intersect(in Ray ray)
{
    Optional<Intersection> isect;
    isect.present = false;
    isect.value.t = 1e20;
    isect.value.i = SPHERES_COUNT;

    for (uint i = 0; i != SPHERES_COUNT; ++i)
    {
        Optional<QuadricIntersection> sIsect = Sphere_intersect(spheres[i], ray, isect.value.t);
        if (sIsect.present)
        {
            isect.present = true;
            isect.value.t = sIsect.value.t;
            isect.value.p = sIsect.value.p;
            isect.value.i = i;
        }
    }
    
    return isect;
}

struct LightSampleContext
{
    float3 p;
    float3 n, ns;
};

struct LightLiSample
{
    float3 L;  // amount of radiance leaving towards a reference point, given in the procedure which generated a LightLiSample
    float3 wi; // direction that, from the reference point, looks at the point from which the radiance comes (a point on the light)
    float pdf; // PDF value for the returned sample
    Interaction pLight;
};

// TODO add support for image with alpha texture, and refactor to use light instead of sphere or shape
float3 DiffuseAreaLight_L(in Sphere shape, in float3 p, in float3 n, /*in float2 uv,*/ in float3 w)
{
    // Check for zero emitted radiance from point on area light
    if (dot(n,w) < 0)
        return float3(0,0,0);

    return shape.emission;
}

// should take the light, not the shape
Optional<LightLiSample> DiffuseAreaLight_sampleLi(in Sphere light, in LightSampleContext ctx, in float2 u)
{
    Optional<LightLiSample> si;
    si.present = false;

    // sample point on shape
    Optional<ShapeSample> ss = Sphere_sample(light, u);
    if (!ss.present || ss.value.pdf == 0 || dot(ss.value.intr.p - ctx.p, ss.value.intr.p - ctx.p) == 0)
        return si;

    // TODO: Check sampled point against alpha texture, if present
  
    // return LightLiSample for sampled point on shape
    float3 wi = normalize(ss.value.intr.p - ctx.p);
    float3 Le = DiffuseAreaLight_L(light, ss.value.intr.p, ss.value.intr.n, /*ss.value.intr.uv,*/-wi/*, lambda*/); // TODO complete
    if (all(Le == float3(0,0,0)))
        return si;

    Optional<LightLiSample> ssi = {{Le, wi, ss.value.pdf, ss.value.intr}, true};
    return si;
}

struct BSDFSample
{
    float3 f;
    float3 wi;
    float pdf;
    //float eta;
    //bool pdfIsProportional; flags, ...
};

Optional<BSDFSample> Diff_sample_f(float3 R, in float3 wo, in float uc, in float2 u)
{
    float3 wi = sampleCosineHemisphere(u);
    if (wo.z < 0)
        wi.z *= -1;

    float pdf = cosineHemispherePDF(abs(wi.z));
    Optional<BSDFSample> bs = {{ R / PI, wi, pdf }, true};
    return bs;
}


// TODO switch to interval arithmetic and to using more structures about sampling. Switch to surface interaction when implementing properly system.
// compose a proper bsdf
float3 sampleLd(in Interaction intr, in Refl_t bsdf, inout LCG lcg)
{
    // initialize LightSampleContext for light sampling
    LightSampleContext ctx = {intr.p, intr.n, intr.n/* = ns, maybe?*/};
    // - TODO: try to nudge the light sampling position to correct side of the surface

    // Choose a light source for direct lighting calculation (TODO, for now hardcoded to the only light in scene)
    float u = random1D(lcg);
    Sphere light = lights[0];

    // Sample a point on the light source for direct lighting
    float2 uLight = random2D(lcg);
    Optional<LightLiSample> ls = DiffuseAreaLight_sampleLi(light, ctx, uLight);
    if (!ls.present || !nonZero(ls.value.L) || ls.value.pdf == 0.f)
        return float3(0,0,0);

    // Evaluate BSDF for light sample and check light visibility: a shadow ray is traced only if BSDF for the sampled direction is nonzero and visible
    float3 wo = intr.wo, wi = ls.value.wi;
    float3 f = 1.f / PI * abs(dot(wi, intr/*.shading.n*/.n)); // TODO
    if (!nonZero(f) /*|| !Unoccluded(intr, ls.value.pLight)*/) // TODO
        return float3(0,0,0);

    // Return light's contribution to reflected radiance
    float p_l = /*light.p * */ls.value.pdf; // TODO
    // - TODO add check deltalight page 837
    float p_b = cosineHemispherePDF(abs(wi.z)); // TODO
    float w_l = powerHeuristic(1, p_l, 1, p_b);
    return w_l * ls.value.L * f / p_l;
}

#define MAX_DEPTH 10

// TODO remove any reference to spheres and build up aggregate
float3 Li(in Ray startRay, inout LCG lcg)
{
    float3 L = {0,0,0}, beta = {1,1,1}; // L <- radiance, beta <- throughput
    bool specularBounce = false, anyNonSpecularBounces = false;
    uint depth = 0;
    Ray ray = startRay; 
    float p_b = 1, etaScale = 1; // PDF for chosen BSDF in the path
    LightSampleContext prevIntrCtx;
    prevIntrCtx.p = prevIntrCtx.n = prevIntrCtx.ns = float3(0,0,0);

    while (true)
    {
        // Scene Intersection
        Optional<Intersection> isect = intersect(ray);
        if (!isect.present)
        {
            // TODO lights at infinity
            break;
        }

        uint i = isect.value.i;
        float3 p  = isect.value.p;
        float3 n  = abs(normalize(p - spheres[i].position));
        float3 wo = -ray.d;

        // incorporate Le if surface is emissive
        float3 Le = spheres[i].emission;

        if (nonZero(Le))
        {
            // if ray comes from a specular bounce or the light source is the first intersection,
            // then don't apply MIS
            if (specularBounce || depth == 0)
                L += beta * Le;
            else // prevIntrCtx is fully initialized because depth > 0
            {
                // compute PDF for chosen light as product of PMF of choosing the light and PDF of the distribution of directions of the light
                // TODO: now there is just one light, and it is known to have uniform PDF in all directions
                ShapeSampleContext ctx;
                ctx.p = prevIntrCtx.p;
                ctx.n = prevIntrCtx.n;
                ctx.ns = prevIntrCtx.ns;
                ctx.time = 0;
                float p_l = 1/*PMF*/ * Sphere_PDF(spheres[i], ctx, ray.d);
                float w_l = powerHeuristic(1, p_l, 1, p_b);
                L += beta * w_l * Le;
            }
        }

        // TODO: implement BSDF properly, and allow an area light to not have a bsdf
        Refl_t bsdf = spheres[i].refl;
        // TODO implement filtering, and register albedo of first surface to the film. Implement BSDF regularization?
        
        if (depth++ == MAX_DEPTH)
            break;

        // if the BSDF is diffuse, then compute direct lighting, because if the surface accumulates and scatters light from many directions,
        // it can almost surely see most of the light sources
        Interaction intr = { p, n, isect.value.t, wo };
        if (bsdf == DIFF /*change to checking if non specular*/)
        {
            float3 Ld = sampleLd(intr, DIFF, lcg);
            L += beta * Ld;
        }

        // Sample BSDF to get new path direction TODO better
        float2 xi = random2D(lcg);
        
        float u = random1D(lcg);
        Optional<BSDFSample> bs = Diff_sample_f(spheres[i].color, wo, u, xi);
        if (bs.present == false)
            break;
        
        // - Update path state variables after surface scattering TODO readjust to follow pbrt
        beta *= bs.value.f * abs(dot(bs.value.wi, /*isect.shading.*/n)) / /*BSDF pdf*/bs.value.pdf;
        p_b = bs.value.pdf;
        specularBounce = bsdf != DIFF;
        anyNonSpecularBounces |= bsdf == DIFF;
        // TODO transmission
        LightSampleContext ctx = {intr.p, intr.n, intr.n/* = ns, maybe?*/};
        prevIntrCtx = ctx;

        Vector3fi pi = Vector3fi(p, float3(0.01,0.01,0.01));
        ray.o = OffsetRayOrigin(pi, n, bs.value.wi);
        ray.d = bs.value.wi;
        ray.time = 0;

        // Possibly terminate the path with Russian roulette
        float3 rrBeta = beta * etaScale;
        float rrBetaMaxComp = max(max(rrBeta.x, rrBeta.y), rrBeta.z);
        if (rrBetaMaxComp < 1 && depth > 1)
        {
            float q = max(0, 1 - rrBetaMaxComp);
            if (random1D(lcg) < q)
                break;
            beta /= 1 - q;
        }
    }

    return L;
}

[numthreads(16,16,1)]
void main(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint raysPerPixel = 8;
    LCG lcg = {push.rngSeed};
    // TODO move this check in C++
    if (push.sampleIndex < push.samplesPerPixel)
    {
        // Get workgroup chunk dimensions
        uint2 dim;
        res.GetDimensions(dim.x, dim.y);

        // get coordinates within chunk, [0,1]->[-1,1]
        float2 fdim = float2(dim.x/dim.y, 1);
        float2 xy = (-1.f + 2.f * (float2(dispatchThreadID.xy) / dim)) * float2(dim.x/dim.y, 1);
        float2 pxdim = fdim / dim;
        
        // get camera from UBO (TODO) float3(50,52,295.6)
        Camera camera = {float3(0,0,0), normalize(float3(0,0,1))};

        // apply aspect ratio (TODO), focal distance (TODO), and construct ray.d
        // use resolution to figure out pixel cell dimensions to sample within the pixel (TODO)

        // assume origin = image plane center, then ray.d = camera lookat + xy
        float3 weightedColour = float3(0,0,0);
        Ray ray; 
        ray.o = camera.position;
        ray.d = float3(0,0,1);
        for (uint i = 0; i != raysPerPixel * 10; ++i)
        {
            float2 offset = float2(random1D(lcg) * pxdim.x / 2, random1D(lcg) * pxdim.y / 2);
            ray.d = normalize(camera.lookat + float3(xy + offset, 0.f));
            float3 finalColour = Li(ray, lcg);
            weightedColour = (push.sampleIndex * transaction[dispatchThreadID.xy].xyz + finalColour) / (push.sampleIndex + 1);
        }

        transaction[dispatchThreadID.xy] = float4(weightedColour, 1.f);
    }

    res[dispatchThreadID.xy] = transaction[dispatchThreadID.xy];
}
