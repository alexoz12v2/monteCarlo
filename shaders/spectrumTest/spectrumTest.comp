// test.compute

#pragma kernel main

[[vk::binding(0, 0)]] RWTexture2D<float4> res;
[[vk::binding(1, 0)]] RWTexture2D<float4> transaction;
[[vk::push_constant]] struct Constants {
    uint rngSeed;
    uint sampleIndex;
    uint samplesPerPixel;
} push;

struct Camera 
{
    float3 position;
    float3 lookat;
};

struct Ray 
{
    float3 origin;
    float3 direction;
};

bool nonZero(in float3 v)
{
    return any(v != float3(0,0,0));
}

float sqr(float x)
{
    return x*x;
}

// implementation of formulas: given a 3D vector v1, a base with it
// can be constructed as
// v2 = [ (1-v1.x^2)/(1+v1.z), -(v1.x*v1.y)/(1+v1.z), -v1.x ]
// v3 = [ -(v1.x*v1.y)/(1+v1.z), (1-v1.y^2)/(1+v1.z), -v1.y ]
void coordinateSystem(in float3 v1, out float3 v2, out float3 v3)
{
    float sgn = sign(v1.z);
    float a = -1/(sgn+v1.z);
    float b = v1.x*v1.y*a;

    v2 = float3(1+sgn+sqr(v1.x)*a, sgn*b, -sgn*v1.x);
    v3 = float3(b, sgn+sqr(v1.x)*a, -v1.y);
}

// LinearCongruentialGenerator
struct LCG
{
    uint state;
};

float random1D(inout LCG lcg)
{
    uint next = 16807*(lcg.state+1) % 2147483647u;
    lcg.state = next;
    return float(next) / 2147483647u;
}

float2 random2D(inout LCG lcg)
{
    return float2(random1D(lcg), random1D(lcg));
}

float3x3 identity()
{
    return float3x3(
        1.f, 0.f, 0.f,
        0.f, 1.f, 0.f,
        0.f, 0.f, 1.f
    );
}

// power heuristic for MIS, computing weight whose nSamples and pdf is the first.
// using power of 2
float powerHeuristic(in uint nf, in float fpdf, in uint ng, in float gpdf)
{
    float num = nf * fpdf;
    if (isinf(sqr(num))) 
        return 1;

    return sqr(num) / (sqr(num)+sqr(ng*gpdf));
}

enum Refl_t { DIFF, SPEC, REFR };  
struct Sphere 
{ 
    float radius;
    float3 position;
    float3 emission;
    float3 color;
    Refl_t refl;
}; 

#define opt_def(T) struct opt_##T { T value; bool present; }
#define opt(T) opt_##T

opt_def(float);

opt_float Sphere_intersect(in Sphere sphere, in Ray ray, in float tMax)
{
    opt_float result;
    result.present = false;

    // transform to coordinate frame 
    float3 ori = ray.origin - sphere.position;
    float eps = 1e-4;

    float a = dot(ray.direction,ray.direction);
    float b = dot(ray.direction, ori);
    float c = dot(ori, ori)-sphere.radius*sphere.radius;
    float det = b*b-a*c;

    if (det>-eps)
    {
        det=sqrt(max(det,0));
        result.value = (-b-det)/a;
        if (result.value < eps)
            result.value = (-b+det)/a;

        if (result.value > eps && result.value <= tMax)
            result.present = true;
    }

    return result;
} 

#define SPHERES_COUNT 9
#define LIGHTS_COUNT 1
#define PI 3.141592654

static Sphere spheres[SPHERES_COUNT] = {
    {1e5, float3( 1e5 + 1, 0, 0), float3(0, 0, 0), float3(.75, .25, .25), DIFF}, // Left Wall (Red)
    {1e5, float3(-1e5 - 1, 0, 0), float3(0, 0, 0), float3(.25, .25, .75), DIFF}, // Right Wall (Blue)
    {1e5, float3(0, 0, -1e5 - 1), float3(0, 0, 0), float3(.75, .75, .75), DIFF}, // Back Wall (White)
    {1e5, float3(0, 0, 1e5 + 2.15), float3(0, 0, 0), float3(.75, .75, .75), DIFF}, // Front Wall (White)
    {1e5, float3(0, -1e5 - 1, 0), float3(0, 0, 0), float3(.75, .75, .75), DIFF}, // Bottom Wall (White)
    {1e5, float3(0, 1e5 + 1, 0), float3(0, 0, 0), float3(.75, .75, .75), DIFF}, // Top Wall (White)
    {0.33, float3(-0.5,1-0.33,1.2), float3(0, 0, 0), float3(0.4, 0.2, 0.2), SPEC}, // Mirror Sphere (Specular reflection)
    {0.45, float3(0.35,1-0.45,1.5), float3(0, 0, 0), float3(0.3, 1, 1), REFR}, // Glossy Sphere (Refractive material)
    {1,    float3(0,-1.9,1.5), float3(1, 1, 1), float3(0, 0, 0), DIFF} // Light Sphere (Light-emitting sphere)
}; 

static Sphere lights[LIGHTS_COUNT] = {
    {1, float3(0,-1.9,1.5), float3(12, 12, 12), float3(0, 0, 0), DIFF} // Light Sphere (Light-emitting sphere)
};

struct Intersection {
    float t;
    uint i;
};

opt_def(Intersection);

float3 sphericalDirection(in float sinTheta, in float cosTheta, in float phi)
{
    return normalize(float3( sinTheta*cos(phi), sinTheta*sin(phi), cosTheta));
}

// assumes sphere in origin, taken from pbrt straight. See also pegoraro page 272
float3 sampleUniformSphere(in float2 u)
{
    float z = 1 - 2 * u[0];
    float r = sqrt(max(0,1-sqr(z)));
    float phi = 2 * PI * u[1];
    return float3(r * cos(phi), r * sin(phi), z);
}

// assumes cone normal (0,0,1)
float3 sampleUniformCone(in float2 u, in float cosThetaMax)
{
    float cosTheta = lerp(1, cosThetaMax, u[0]);
    float sinTheta = sqrt(max(1-cosTheta*cosTheta, 0));
    float phi = u[1] * 2 * PI;
    return sphericalDirection(sinTheta, cosTheta, phi);
}

// pbrt
float2 sampleUniformDiskConcentric(in float2 u)
{
    // Map _u_ to $[-1,1]^2$ and handle degeneracy at the origin
    float2 uOffset = 2 * u - float2(1, 1);
    if (uOffset.x == 0 && uOffset.y == 0)
        return float2(0, 0);

    // Apply concentric mapping to point
    float theta, r;
    if (abs(uOffset.x) > abs(uOffset.y)) {
        r = uOffset.x;
        theta = PI/4* (uOffset.y / uOffset.x);
    } else {
        r = uOffset.y;
        theta = PI/2 - PI/4 * (uOffset.x / uOffset.y);
    }
    return r * float2(cos(theta), sin(theta));
}

float3 sampleCosineHemisphere(in float2 u) 
{
    float2 d = sampleUniformDiskConcentric(u);
    float z = sqrt(max(0.f, 1.f - sqr(d.x) - sqr(d.y)));
    return float3(d.x,d.y,z);
}

float cosineHemispherePDF(in float cosTheta)
{
    return cosTheta / PI;
}

opt_Intersection intersect(in Ray ray)
{
    opt_Intersection isect;
    isect.present = false;
    isect.value.t = 1e20;
    isect.value.i = SPHERES_COUNT;

    for (uint i = 0; i != SPHERES_COUNT; ++i)
    {
        opt_float sIsect = Sphere_intersect(spheres[i], ray, isect.value.t);
        if (sIsect.present)
        {
            isect.present = true;
            isect.value.t = sIsect.value;
            isect.value.i = i;
        }
    }
    
    return isect;
}

// only surface 
struct Interaction
{
    float3 p;   // point of surface intersected
    float3 n;   // geometric normal of intersected
    // no uv for now
    float time; // ray step parameter 
    float3 wo;  // direction negative to the direction of the ray (hence, outgoing)
};

struct LightSampleContext
{
    float3 p;
    float3 n, ns;
};

struct LightLiSample
{
    float3 L;  // amount of radiance leaving towards a reference point, given in the procedure which generated a LightLiSample
    float3 wi; // direction that, from the reference point, looks at the point from which the radiance comes (a point on the light)
    float pdf; // PDF value for the returned sample
    Interaction pLight;
};
opt_def(Interaction);

struct ShapeSampleContext
{
    float3 p;     // reference point, i.e. a point from which we are observing the shape
    float3 n, ns; // geometric and shading normal of reference point
    float time;   // ray parameter for the ray that intersected the reference point
};

struct ShapeIntersection
{
    // TODO surface interaction
    Interaction intr;
    float tHit;
};

opt_def(ShapeIntersection);

float3 ShapeSampleContext_offsetRayOrigin(in ShapeSampleContext ctx, float3 w)
{
    // TODO interval arithmetic
    float3 po = ctx.p;
    return po;
}

struct ShapeSample
{
    Interaction intr;
    float pdf;
};

opt_def(ShapeSample);

opt_def(LightLiSample);

opt_ShapeSample Sphere_sample(in Sphere sphere, in float2 u)
{
    float3 pObj = float3(0,0,0) + sphere.radius*sampleUniformSphere(u);
    // TODO interval arithmetic

    // compute surface normal (point itself normalized in object space) for sphere sample and return
    float3 nObj = normalize(pObj);
    // TODO renderFromObject transform
    float3 p = pObj - sphere.position;
    // TODO support for inverse orientation normal
    Interaction intr = {p, nObj, 0, float3(0,0,0)};
    opt_ShapeSample ss = {{intr, 1 /(4*PI)}, true};
    return ss;
}

opt_ShapeSample Sphere_sampleW(in Sphere sphere, in ShapeSampleContext ctx, in float2 u)
{
    // sample uniformly on sphere if ctx.p is inside it, since the whole sphere is visible from within. 
    // TODO change sphere to be in object space and carry a transform
    float3 pCenter = sphere.position;
    float3 pOrigin = ShapeSampleContext_offsetRayOrigin(ctx,pCenter-ctx.p);

    if (dot(pOrigin, pCenter) <= sqr(sphere.radius))
    {
        // sample by area sphere and compute incident direction wi
        opt_ShapeSample ss = Sphere_sample(sphere, u);
        ss.value.intr.time = ctx.time;
        float3 wi = ss.value.intr.p - ctx.p;
        if (dot(wi,wi) == 0) 
        {
            ss.present = false;
            return ss;
        }

        wi = normalize(wi);

        // convert area sampling PDF to solid angle, dwi/dA = cosThetaO / r^2 by the definition of solid angle
        ss.value.pdf /= abs(dot(ss.value.intr.n, -wi)) / dot(ctx.p, ss.value.intr.p);
        ss.present = true;
        if (isinf(ss.value.pdf)) ss.present = false;
        
        return ss;
    }

    // sample sphere uniformly inside subtended cone (visible portion of sphere from reference point ctx.p)
    // 1- compute quantities related to the thetaMax (TODO) for the visibility cone
    float sinThetaMax  = sphere.radius / distance(ctx.p, pCenter);
    float sin2ThetaMax = sqr(sinThetaMax);
    float cosThetaMax  = sqrt(max(0.f,1.f-sin2ThetaMax));
    float oneMinusCosThetaMax = 1 - cosThetaMax;

    // 2- compute theta and phi values for sample in cone
    float cosTheta = (cosThetaMax - 1) * u[0] + 1;
    float sin2Theta = 1 - sqr(cosTheta);
    if (sin2ThetaMax < 0.00068523f/*= sin^2(1.5 deg)*/)
    {
        // compute sona sample via Taylor series expnasion for small angles
        sin2Theta = sin2ThetaMax * u[0];
        cosTheta = sqrt(1 - sin2Theta);
        oneMinusCosThetaMax = sin2ThetaMax / 2;
    }
  
    // 3- compute angle alpha from center of sphere to sampled point on surface
    float cosAlpha = sin2Theta / sinThetaMax + cosTheta * sqrt(max(0.f, 1.f - sin2Theta / sin2ThetaMax));
    float sinAlpha = sqrt(max(0.f, 1.f - sqr(cosAlpha)));
   
    // 4- compute surface normal and sampled point on sphere
    float phi = u[1] * 2 * PI;
    float3 w = sphericalDirection(sinAlpha, cosAlpha, phi); // sampled direction, whose negation gives the normal of the sphere (used in line 322)
    // TODO: refactor in Frame class, as in pbrt
    float3 x, y, z = normalize(pCenter - ctx.p);
    coordinateSystem(z, x, y);
    float3 n = -w.x * x - w.y * y - w.z * z;
    float3 p = pCenter + sphere.radius * n;
    //TODO: support for reverse orientation
 
    // return result
    // TODO: compute error and uv coordinates for sampled point on sphere
    opt_ShapeSample ss = {{ {p, n, ctx.time,/*no uv*/ /*wo*/float3(0,0,0)}, 1 / (2 * PI * oneMinusCosThetaMax) }, true};
    return ss;
}

// TODO add support for image with alpha texture, and refactor to use light instead of sphere or shape
float3 DiffuseAreaLight_L(in Sphere shape, in float3 p, in float3 n, /*in float2 uv,*/ in float3 w)
{
    // Check for zero emitted radiance from point on area light
    if (dot(n,w) < 0)
        return float3(0,0,0);

    return shape.emission;
}

// should take the light, not the shape
opt_LightLiSample DiffuseAreaLight_sampleLi(in Sphere light, in LightSampleContext ctx, in float2 u)
{
    opt_LightLiSample si;
    si.present = false;

    // sample point on shape
    opt_ShapeSample ss = Sphere_sample(light, u);
    if (!ss.present || ss.value.pdf == 0 || dot(ss.value.intr.p - ctx.p, ss.value.intr.p - ctx.p) == 0)
        return si;

    // TODO: Check sampled point against alpha texture, if present
  
    // return LightLiSample for sampled point on shape
    float3 wi = normalize(ss.value.intr.p - ctx.p);
    float3 Le = DiffuseAreaLight_L(light, ss.value.intr.p, ss.value.intr.n, /*ss.value.intr.uv,*/-wi/*, lambda*/); // TODO complete
    if (all(Le == float3(0,0,0)))
        return si;

    opt_LightLiSample ssi = {{Le, wi, ss.value.pdf, ss.value.intr}, true};
    return si;
}

struct BSDFSample
{
    float3 f;
    float3 wi;
    float pdf;
    //float eta;
    //bool pdfIsProportional; flags, ...
};

opt_def(BSDFSample);

opt_BSDFSample Diff_sample_f(float3 R, in float3 wo, in float uc, in float2 u)
{
    float3 wi = sampleCosineHemisphere(u);
    if (wo.z < 0)
        wi.z *= -1;

    float pdf = cosineHemispherePDF(abs(wi.z));
    opt_BSDFSample bs = {{ R / PI, wi, pdf }, true};
    return bs;
}

// TODO switch to interval arithmetic and to using more structures about sampling. Switch to surface interaction when implementing properly system.
// compose a proper bsdf
float3 sampleLd(in Interaction intr, in Refl_t bsdf, inout LCG lcg)
{
    // initialize LightSampleContext for light sampling
    LightSampleContext ctx = {intr.p, intr.n, intr.n/* = ns, maybe?*/};
    // - TODO: try to nudge the light sampling position to correct side of the surface

    // Choose a light source for direct lighting calculation (TODO, for now hardcoded to the only light in scene)
    float u = random1D(lcg);
    Sphere light = lights[0];

    // Sample a point on the light source for direct lighting
    float2 uLight = random2D(lcg);
    opt_LightLiSample ls = DiffuseAreaLight_sampleLi(light, ctx, uLight);
    if (!ls.present || all(ls.value.L == float3(0,0,0)) || ls.value.pdf == 0.f)
        return float3(0,0,0);

    // Evaluate BSDF for light sample and check light visibility: a shadow ray is traced only if BSDF for the sampled direction is nonzero and visible
    float3 wo = intr.wo, wi = ls.value.wi;
    float3 f = 1.f / PI * abs(dot(wi, intr/*.shading.n*/.n)); // TODO
    if (all(f == float3(0,0,0)) /*|| !Unoccluded(intr, ls.value.pLight)*/) // TODO
        return float3(0,0,0);

    // Return light's contribution to reflected radiance
    float p_l = /*light.p * */ls.value.pdf; // TODO
    // - TODO add check deltalight page 837
    float p_b = cosineHemispherePDF(abs(wi.z)); // TODO
    float w_l = powerHeuristic(1, p_l, 1, p_b);
    return w_l * ls.value.L * f / p_l;
}

#define MAX_DEPTH 10

// TODO remove any reference to spheres and build up aggregate
float3 Li(in Ray startRay, inout LCG lcg)
{
    float3 L = {0,0,0}, beta = {1,1,1}; // L <- radiance, beta <- throughput
    bool specularBounce = false, anyNonSpecularBounces = false;
    uint depth = 0;
    Ray ray = startRay;
    float p_b = 1, etaScale = 1; // PDF for chosen BSDF in the path
    LightSampleContext prevIntrCtx;

    while (true)
    {
        // Scene Intersection
        opt_Intersection isect = intersect(ray);
        if (!isect.present)
        {
            // TODO lights at infinity
            break;
        }

        uint i = isect.value.i;
        float3 p  = ray.origin + isect.value.t * ray.direction;
        float3 n  = normalize(p - spheres[i].position);
        float3 wo = -ray.direction;

        // incorporate Le if surface is emissive
        float3 Le = spheres[i].emission;
        if (nonZero(Le))
        {
            // if ray comes from a specular bounce or the light source is the first intersection,
            // then don't apply MIS
            if (specularBounce || depth == 0)
                L += beta * Le;
            else
            {
                // compute PDF for chosen light as product of PMF of choosing the light and PDF of the distribution of directions of the light
                // TODO: now there is just one light, and it is known to have uniform PDF in all directions
                float p_l = 1/*PMF*/ * 1/(4*PI)/*PDF*/;
                float w_l = powerHeuristic(1, p_l, 1, p_b);
                L += beta * w_l * Le;
            }
        }

        // TODO: implement BSDF properly, and allow an area light to not have a bsdf
        Refl_t bsdf = spheres[i].refl;
        // TODO implement filtering, and register albedo of first surface to the film. Implement BSDF regularization?
        
        if (depth++ == MAX_DEPTH)
            break;

        // if the BSDF is diffuse, then compute direct lighting, because if the surface accumulates and scatters light from many directions,
        // it can almost surely see most of the light sources
        Interaction intr = { p, n, isect.value.t, wo };
        if (bsdf == DIFF /*change to checking if non specular*/)
        {
            float3 Ld = sampleLd(intr, DIFF, lcg);
        }

        // Sample BSDF to get new path direction TODO better
        float2 xi = random2D(lcg);
        //float cos2Theta = max(0.f, 1.f-xi[0]);
        //float cosTheta = sqrt(cos2Theta);
        //float sinTheta = sqrt(max(0.f, 1.f-cos2Theta));
        //float phi = 2 * PI * xi[1];
        //float3 dir = sphericalDirection(sinTheta, cosTheta, phi);
        
        float u = random1D(lcg);
        opt_BSDFSample bs = Diff_sample_f(spheres[i].color, wo, u, xi);
        if (bs.present == false)
            break;
        
        // - Update path state variables after surface scattering TODO readjust to follow pbrt
        beta *= spheres[i].color * abs(dot(bs.value.wi, /*isect.shading.*/n)) / /*BSDF pdf*/bs.value.pdf;
        p_b = bs.value.pdf;
        specularBounce = bsdf != DIFF;
        anyNonSpecularBounces |= bsdf == DIFF;
        // TODO transmission
        LightSampleContext ctx = {intr.p, intr.n, intr.n/* = ns, maybe?*/};
        prevIntrCtx = ctx;

        ray.origin = p;
        ray.direction = bs.value.wi;

        // Possibly terminate the path with Russian roulette
        float3 rrBeta = beta * etaScale;
        float rrBetaMaxComp = max(max(rrBeta.x, rrBeta.y), rrBeta.z);
        if (rrBetaMaxComp < 1 && depth > 1)
        {
            float q = max(0, 1 - rrBetaMaxComp);
            if (random1D(lcg) < q)
                break;
            beta /= 1 - q;
        }
    }

    return L;
}

[numthreads(16,16,1)]
void main(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint raysPerPixel = 8;
    LCG lcg = {push.rngSeed};
    // TODO move this check in C++
    if (push.sampleIndex < push.samplesPerPixel)
    {
        // Get workgroup chunk dimensions
        uint2 dim;
        res.GetDimensions(dim.x, dim.y);

        // get coordinates within chunk, [0,1]->[-1,1]
        float2 fdim = float2(dim.x/dim.y, 1);
        float2 xy = (-1.f + 2.f * (float2(dispatchThreadID.xy) / dim)) * float2(dim.x/dim.y, 1);
        float2 pxdim = fdim / dim;
        
        // get camera from UBO (TODO) float3(50,52,295.6)
        Camera camera = {float3(0,0,0), normalize(float3(0,0,1))};

        // apply aspect ratio (TODO), focal distance (TODO), and construct ray direction
        // use resolution to figure out pixel cell dimensions to sample within the pixel (TODO)

        // assume origin = image plane center, then ray direction = camera lookat + xy
        float3 weightedColour = float3(0,0,0);
        Ray ray = { camera.position, float3(0,0,1) };
        for (uint i = 0; i != raysPerPixel; ++i)
        {
            float2 offset = float2(random1D(lcg) * pxdim.x / 2, random1D(lcg) * pxdim.y / 2);
            ray.direction = normalize(camera.lookat + float3(xy + offset, 0.f));
            float3 finalColour = Li(ray, lcg);
            weightedColour = (push.sampleIndex * transaction[dispatchThreadID.xy].xyz + finalColour) / (push.sampleIndex + 1);
        }

        transaction[dispatchThreadID.xy] = float4(weightedColour, 1.f);
    }

    res[dispatchThreadID.xy] = transaction[dispatchThreadID.xy];
}
